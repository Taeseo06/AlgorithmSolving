# [백준] 25335번 - C언어 / {실버5}

백준 25335번 문제풀이를 C언어를 사용하여 시도해보았다.

이 문제는 선린인터넷고등학교_제 6회 천하제일 코딩대회 본선_A문제이다.

[25335번: Gravity Hackenbush](https://www.acmicpc.net/problem/25335)

---

입력 : 점(N)과 선(M)의 갯수, N에 해당하는 i번 점의 좌표(x, y), M에 해당하는 i번 줄의 좌표(연결되는 두 점의 번호, 줄의 색깔)

출력 : Gravity Hackenbush 게임의 승자

알고리즘 : 입력되는 선의 색깔(R, G, B)에 따라 1플레이어와 2플레이어의 승리여부를 가른다.

핵심조건 : 

빨간색 선은 1번 플레이어만 자를 수 있다.

파란색 선은 2번 플레이어만 자를 수 있다.

초록색 선은 두 플레이어 모두가 자를 수 있다.

이렇게 각 플레이어마다 자를 수 있는 조건이 제한되어있으므로 이 조건에만 유의하며 생각해보면 문제를 쉽게 풀어낼 수 있다.

1. “우선, 각 플레이어는 자신에게 가장 이익이되도록 최선의 플레이를 할 것이다” = 자신의 차례때, 두 플레이어 모두가 자를 수 있는 초록색 선을 먼저 자르려고 생각할 것이다.
2. 초록색 선이 모두 잘리면 플레이어는 원치 않더라도 자신이 자를 수 있는 색의 선을 자를 것이다.

위 두가지의 규칙을 생각하면 복잡한알고리즘 없이 쉽게 승자를 가려낼 수 있다. - 선의 색과 갯수로만 !!

---

```c
#include<stdio.h>
int main(void) {
    
    int dot, line;
    scanf("%d %d", &dot, &line);  // 점과 선의 갯수를 입력, 저장
    
    for (int i = 0; i < dot; i++) {
        int a, b;  // 점의 좌표를 입력받을 변수를 지역함수로 사용함 = 따로 저장하지 않음
        scanf("%d %d", &a, &b);  // 점의 갯수에 맞게 각 좌표를 입력받음
    }
    
    int cor[3] = {0, 0, 0};  // 0:G, 1:R, 2:B  // 각 색깔에 선을 구분하고자 크기 3의 배열을 선언
    
    for (int i = 0; i < line; i++) {
        int a, b;  // 연결된 선의 번호(정수)와 선의 색깔(문자)를 입력받고자 지역변수를 사용 = 따로 저장하지 않고 for문 내에서 처리함
        char input;
        scanf("%d %d %c", &a, &b, &input);  // 연결된는 점의 번호(2), 연결하는 선의 색깔(문자)를 입력, 저장
        
        if (input == 'G') {  // 선이 초록색일때
            cor[0] += 1;
        }
        else if (input == 'R') {  // 선이 빨간색일때
            cor[1] += 1;
        }
        else if (input == 'B') {  // 선이 파란색일때
            cor[2] += 1;
        }
    }
    
    int player = 1;  // 첫 시작은 플레이어1
    
    while (1) {
        if (player == 1) {  // 플레이어1 일때
            if (cor[0]) {  // 초록색 선이 있을때
                cor[0] -= 1;
            }
            else if (cor[1]) {  // 자신의 선이 있을때
                cor[1] -= 1;
            }
            else {
                printf("jhnan917");
                break;
            }
            player += 1;  // player1 -> player2
            
        }
        else if (player == 2) {  // 플레이어2 일때
            if (cor[0]) {  // 초록색 선이 있을때
                cor[0] -= 1;
            }
            else if (cor[2]) {  // 자신의 선이 있을때
                cor[2] -= 1;
            }
            else {
                printf("jhnah917");
                break;
            }
            player -= 1;  // player2 -> player1
        }
    }
}
```

코드설명 : 

1. 점과 선의 갯수를 입력받고, 저장한다.
2. 점의 갯수에 맞게 좌표를 입력받는다. !!.다시 사용되지 않을 데이터라 지역변수를 사용하여 임시적으로 저장
3. 선의 갯수에 맞게 연결되는 점들의 번호와 선의 색을 입력받는다. !!.연결되는 점들의 번호는 다시 사용되지 않을 데이터라 지역변수를 사용하여 임시적으로 저장한다, 선의 색을 입력받고 input(지역변수)에 저장하여 뒤에 for문 내부에서 처리한다.
4. if문을 사용하여 선의 색깔을 초록색, 빨간색, 파란색(G, R, B)로 구분하고 그에따라 cor배열에 값을 순서대로 증가시킨다.
5. 플레이어1 부터 시작하여 자기 순서때에 초록색(cor[0] : G)가 있으면 감소시키고 턴을 다른 플레이어에게 넘기며, 초록색 선이 남아있지 않으면 자신이 자를 수 있는 색의 선을 감소시킨다.
6. 이렇게 계속 반복하다가, 자신이 자를 수 있는 선이 남아있지 않으면 패배하여 게임이 끝난다.

---

> 문제를 살펴보면 문제에 대한 설명이 굉장히 길고, 당항스러운 그래프까지 사용되어있다. 또한 여러가지의 함정 (필요없는 데이터)가 많이 포함되어있다.
> 

이 문제를 풀기 위해서는 문제의 지문을 자세히 읽고 핵심 조건을 찾아내어야 하는 문제였다.

---

### 개선사항:

위 코드처럼 플레이어 하나하나를 따로 계산하여 돌아가며 구현할 필요 없이 처음 입력을 받았을때 선의 색과 그 갯수만으로도 바로 승리자를 가려낼 수 있을것 같다.
